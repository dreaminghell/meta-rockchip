From 4b979dc34519aa5cbb92a7c21ab46dbb9282ed2a Mon Sep 17 00:00:00 2001
From: Daniel Stone <daniels@collabora.com>
Date: Tue, 1 Nov 2016 22:21:08 +0000
Subject: [PATCH 40/94] compositor-drm: Drop output from release_fb
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

We only need it for the GBM surface the FB was originally created
against; a mismatch here is very bad indeed, so no reason to pass it in
explictly every time rather than store it.

Following patches change drm_fb to be explicitly reference counted; in
order to reduce churn, rename drm_output_release_fb to drm_fb_unref
whilst changing its call signature here, even though it does not yet
actually perform reference counting.

Differential Revision: https://phabricator.freedesktop.org/D1490

Signed-off-by: Daniel Stone <daniels@collabora.com>
Reviewed-by: Armin KrezoviÄ‡ <krezovic.armin@gmail.com>
Reviewed-by: Pekka Paalanen <pekka.paalanen@collabora.co.uk>
---
 src/compositor-drm.c | 20 +++++++++++---------
 1 file changed, 11 insertions(+), 9 deletions(-)

diff --git a/src/compositor-drm.c b/src/compositor-drm.c
index 55e618b..971d11f 100644
--- a/src/compositor-drm.c
+++ b/src/compositor-drm.c
@@ -153,6 +153,7 @@ struct drm_fb {
 
 	/* Used by gbm fbs */
 	struct gbm_bo *bo;
+	struct gbm_surface *gbm_surface;
 
 	/* Used by dumb fbs */
 	void *map;
@@ -498,7 +499,7 @@ drm_fb_set_buffer(struct drm_fb *fb, struct weston_buffer *buffer)
 }
 
 static void
-drm_output_release_fb(struct drm_output *output, struct drm_fb *fb)
+drm_fb_unref(struct drm_fb *fb)
 {
 	if (!fb)
 		return;
@@ -511,7 +512,7 @@ drm_output_release_fb(struct drm_output *output, struct drm_fb *fb)
 		gbm_bo_destroy(fb->bo);
 		break;
 	case BUFFER_GBM_SURFACE:
-		gbm_surface_release_buffer(output->gbm_surface, fb->bo);
+		gbm_surface_release_buffer(fb->gbm_surface, fb->bo);
 		break;
 	default:
 		assert(NULL);
@@ -627,6 +628,7 @@ drm_output_render_gl(struct drm_output *output, pixman_region32_t *damage)
 		gbm_surface_release_buffer(output->gbm_surface, bo);
 		return;
 	}
+	output->next->gbm_surface = output->gbm_surface;
 }
 
 static void
@@ -811,7 +813,7 @@ drm_output_repaint(struct weston_output *output_base,
 err_pageflip:
 	output->cursor_view = NULL;
 	if (output->next) {
-		drm_output_release_fb(output, output->next);
+		drm_fb_unref(output->next);
 		output->next = NULL;
 	}
 
@@ -912,7 +914,7 @@ vblank_handler(int fd, unsigned int frame, unsigned int sec, unsigned int usec,
 	drm_output_update_msc(output, frame);
 	output->vblank_pending = 0;
 
-	drm_output_release_fb(output, s->current);
+	drm_fb_unref(s->current);
 	s->current = s->next;
 	s->next = NULL;
 
@@ -942,7 +944,7 @@ page_flip_handler(int fd, unsigned int frame,
 	 * we just want to page flip to the current buffer to get an accurate
 	 * timestamp */
 	if (output->page_flip_pending) {
-		drm_output_release_fb(output, output->current);
+		drm_fb_unref(output->current);
 		output->current = output->next;
 		output->next = NULL;
 	}
@@ -1520,8 +1522,8 @@ drm_output_switch_mode(struct weston_output *output_base, struct weston_mode *mo
 		WL_OUTPUT_MODE_CURRENT | WL_OUTPUT_MODE_PREFERRED;
 
 	/* reset rendering stuff. */
-	drm_output_release_fb(output, output->current);
-	drm_output_release_fb(output, output->next);
+	drm_fb_unref(output->current);
+	drm_fb_unref(output->next);
 	output->current = output->next = NULL;
 
 	if (b->use_pixman) {
@@ -2623,8 +2625,8 @@ destroy_sprites(struct drm_backend *backend)
 				sprite->plane_id,
 				output->crtc_id, 0, 0,
 				0, 0, 0, 0, 0, 0, 0, 0);
-		drm_output_release_fb(output, sprite->current);
-		drm_output_release_fb(output, sprite->next);
+		drm_fb_unref(sprite->current);
+		drm_fb_unref(sprite->next);
 		weston_plane_release(&sprite->plane);
 		free(sprite);
 	}
-- 
1.9.1

