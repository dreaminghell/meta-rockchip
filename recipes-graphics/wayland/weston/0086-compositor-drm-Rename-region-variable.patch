From 3ec864f24729854be5d1317495dbc4b60437d25a Mon Sep 17 00:00:00 2001
From: Daniel Stone <daniels@collabora.com>
Date: Tue, 8 Nov 2016 21:19:22 +0000
Subject: [PATCH 86/94] compositor-drm: Rename region variable

Make it a bit more clear what the purpose of the variable is.

Signed-off-by: Daniel Stone <daniels@collabora.com>

Differential Revision: https://phabricator.freedesktop.org/D1528
---
 src/compositor-drm.c | 11 ++++++-----
 1 file changed, 6 insertions(+), 5 deletions(-)

diff --git a/src/compositor-drm.c b/src/compositor-drm.c
index 6bc4a85..0fdeb21 100644
--- a/src/compositor-drm.c
+++ b/src/compositor-drm.c
@@ -2820,7 +2820,7 @@ drm_assign_planes(struct weston_output *output_base, void *repaint_data)
 	struct drm_output_state *state;
 	struct drm_plane_state *plane_state;
 	struct weston_view *ev;
-	pixman_region32_t overlap, surface_overlap;
+	pixman_region32_t surface_overlap, renderer_region;
 	struct weston_plane *primary, *next_plane;
 
 	assert(!output->state_last);
@@ -2841,7 +2841,7 @@ drm_assign_planes(struct weston_output *output_base, void *repaint_data)
 	 * the client buffer can be used directly for the sprite surface
 	 * as we do for flipping full screen surfaces.
 	 */
-	pixman_region32_init(&overlap);
+	pixman_region32_init(&renderer_region);
 	primary = &output_base->compositor->primary_plane;
 
 	wl_list_for_each(ev, &output_base->compositor->view_list, link) {
@@ -2865,7 +2865,7 @@ drm_assign_planes(struct weston_output *output_base, void *repaint_data)
 			es->keep_buffer = false;
 
 		pixman_region32_init(&surface_overlap);
-		pixman_region32_intersect(&surface_overlap, &overlap,
+		pixman_region32_intersect(&surface_overlap, &renderer_region,
 					  &ev->transform.boundingbox);
 
 		next_plane = NULL;
@@ -2883,7 +2883,8 @@ drm_assign_planes(struct weston_output *output_base, void *repaint_data)
 		weston_view_move_to_plane(ev, next_plane);
 
 		if (next_plane == primary)
-			pixman_region32_union(&overlap, &overlap,
+			pixman_region32_union(&renderer_region,
+					      &renderer_region,
 					      &ev->transform.boundingbox);
 
 		if (next_plane == primary ||
@@ -2900,7 +2901,7 @@ drm_assign_planes(struct weston_output *output_base, void *repaint_data)
 
 		pixman_region32_fini(&surface_overlap);
 	}
-	pixman_region32_fini(&overlap);
+	pixman_region32_fini(&renderer_region);
 
 	/* We rely on ev->cursor_view being both an accurate reflection of the
 	 * cursor plane's state, but also being maintained across repaints to
-- 
1.9.1

