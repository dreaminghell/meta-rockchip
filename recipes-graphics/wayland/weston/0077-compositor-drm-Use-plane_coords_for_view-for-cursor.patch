From 31c75113b723dc3030ea363c5870d37afa36c8ee Mon Sep 17 00:00:00 2001
From: Daniel Stone <daniels@collabora.com>
Date: Wed, 16 Nov 2016 19:46:35 +0000
Subject: [PATCH 77/94] compositor-drm: Use plane_coords_for_view for cursor

Use the new helper to populate the cursor state as well, with some
special-case handling to account for how we always upload a full-size
BO.

Signed-off-by: Daniel Stone <daniels@collabora.com>
Reported-by: Derek Foreman <derekf@osg.samsung.com>

Differential Revision: https://phabricator.freedesktop.org/D1519
---
 src/compositor-drm.c | 48 ++++++++++++++++++++++++------------------------
 1 file changed, 24 insertions(+), 24 deletions(-)

diff --git a/src/compositor-drm.c b/src/compositor-drm.c
index 3b1a199..3bd815d 100644
--- a/src/compositor-drm.c
+++ b/src/compositor-drm.c
@@ -2616,10 +2616,8 @@ drm_output_prepare_cursor_view(struct drm_output_state *output_state,
 	struct drm_backend *b = to_drm_backend(output->base.compositor);
 	struct drm_plane *plane = output->cursor_plane;
 	struct drm_plane_state *plane_state;
-	struct weston_buffer_viewport *viewport = &ev->surface->buffer_viewport;
 	struct wl_shm_buffer *shmbuf;
 	bool needs_update = false;
-	float x, y;
 
 	if (!plane)
 		return NULL;
@@ -2649,16 +2647,6 @@ drm_output_prepare_cursor_view(struct drm_output_state *output_state,
 	if (wl_shm_buffer_get_format(shmbuf) != WL_SHM_FORMAT_ARGB8888)
 		return NULL;
 
-	if (output->base.transform != WL_OUTPUT_TRANSFORM_NORMAL)
-		return NULL;
-	if (ev->transform.enabled &&
-	    (ev->transform.matrix.type > WESTON_MATRIX_TRANSFORM_TRANSLATE))
-		return NULL;
-	if (viewport->buffer.scale != output->base.current_scale)
-		return NULL;
-	if (ev->geometry.scissor_enabled)
-		return NULL;
-
 	if (ev->surface->width > b->cursor_width ||
 	    ev->surface->height > b->cursor_height)
 		return NULL;
@@ -2669,6 +2657,26 @@ drm_output_prepare_cursor_view(struct drm_output_state *output_state,
 	if (plane_state && plane_state->fb)
 		return NULL;
 
+	/* We can't scale with the legacy API, and we don't try to account for
+	 * simple cropping/translation in cursor_bo_update. */
+	plane_state->output = output;
+	drm_plane_state_coords_for_view(plane_state, ev);
+	if (plane_state->src_x != 0 || plane_state->src_y != 0 ||
+	    plane_state->src_w > (unsigned) b->cursor_width << 16 ||
+	    plane_state->src_h > (unsigned) b->cursor_height << 16 ||
+	    plane_state->src_w != plane_state->dest_w << 16 ||
+	    plane_state->src_h != plane_state->dest_h << 16)
+		goto err;
+
+	/* The cursor API is somewhat special: in cursor_bo_update(), we upload
+	 * a buffer which is always cursor_width x cursor_height, even if the
+	 * surface we want to promote is actually smaller than this. Manually
+	 * mangle the plane state to deal with this. */
+	plane_state->src_w = b->cursor_width << 16;
+	plane_state->src_h = b->cursor_height << 16;
+	plane_state->dest_w = b->cursor_width;
+	plane_state->dest_h = b->cursor_height;
+
 	/* Since we're setting plane state up front, we need to work out
 	 * whether or not we need to upload a new cursor. We can't use the
 	 * plane damage, since the planes haven't actually been calculated
@@ -2685,26 +2693,18 @@ drm_output_prepare_cursor_view(struct drm_output_state *output_state,
 	}
 
 	output->cursor_view = ev;
-	weston_view_to_global_float(ev, 0, 0, &x, &y);
-	plane->base.x = x;
-	plane->base.y = y;
 
 	plane_state->fb =
 		drm_fb_ref(output->gbm_cursor_fb[output->current_cursor]);
-	plane_state->output = output;
-	plane_state->src_x = 0;
-	plane_state->src_y = 0;
-	plane_state->src_w = b->cursor_width << 16;
-	plane_state->src_h = b->cursor_height << 16;
-	plane_state->dest_x = (x - output->base.x) * output->base.current_scale;
-	plane_state->dest_y = (y - output->base.y) * output->base.current_scale;
-	plane_state->dest_w = b->cursor_width;
-	plane_state->dest_h = b->cursor_height;
 
 	if (needs_update)
 		cursor_bo_update(b, plane_state->fb->bo, ev);
 
 	return &plane->base;
+
+err:
+	drm_plane_state_put_back(plane_state);
+	return NULL;
 }
 
 static void
-- 
1.9.1

