From 21978e8c7cd58fa6f7e4eeb13a4253011ccc9ff2 Mon Sep 17 00:00:00 2001
From: Daniel Stone <daniels@collabora.com>
Date: Tue, 1 Nov 2016 17:38:46 +0000
Subject: [PATCH 37/94] compositor-drm: Add explicit type member to drm_fb

Rather than magically trying to infer what the buffer is and what we
should do with it when we go to destroy it, add an explicit type
instead.

In doing so, the test for dumb images (destroying them, but only if
they're not the 'live' ones) is removed. This was dead code, as the only
path which could cause us to shuffle images is drm_output_switch_mode.
This calls drm_output_release_fb before the images are reallocated in
drm_output_fini_pixman / drm_output_init_pixman, with the reallocation
unconditionally destroying the images, so can never be hit.

Differential Revision: https://phabricator.freedesktop.org/D1488

Signed-off-by: Daniel Stone <daniels@collabora.com>
Reviewed-by: Pekka Paalanen <pekka.paalanen@collabora.co.uk>
---
 src/compositor-drm.c | 55 ++++++++++++++++++++++++++++++++++------------------
 1 file changed, 36 insertions(+), 19 deletions(-)

diff --git a/src/compositor-drm.c b/src/compositor-drm.c
index 74b6926..0b53d63 100644
--- a/src/compositor-drm.c
+++ b/src/compositor-drm.c
@@ -134,11 +134,19 @@ struct drm_mode {
 	drmModeModeInfo mode_info;
 };
 
+enum drm_fb_type {
+	BUFFER_INVALID = 0, /**< never used */
+	BUFFER_CLIENT, /**< directly sourced from client */
+	BUFFER_PIXMAN_DUMB, /**< internal Pixman rendering */
+	BUFFER_GBM_SURFACE, /**< internal EGL rendering */
+};
+
 struct drm_fb {
+	enum drm_fb_type type;
+
 	uint32_t fb_id, stride, handle, size;
 	int width, height;
 	int fd;
-	int is_client_buffer;
 	struct weston_buffer_reference buffer_ref;
 
 	/* Used by gbm fbs */
@@ -319,6 +327,7 @@ drm_fb_create_dumb(struct drm_backend *b, int width, int height,
 	if (ret)
 		goto err_fb;
 
+	fb->type = BUFFER_PIXMAN_DUMB;
 	fb->handle = create_arg.handle;
 	fb->stride = create_arg.pitch;
 	fb->size = create_arg.size;
@@ -381,6 +390,8 @@ drm_fb_destroy_dumb(struct drm_fb *fb)
 {
 	struct drm_mode_destroy_dumb destroy_arg;
 
+	assert(fb->type == BUFFER_PIXMAN_DUMB);
+
 	if (!fb->map)
 		return;
 
@@ -399,20 +410,23 @@ drm_fb_destroy_dumb(struct drm_fb *fb)
 }
 
 static struct drm_fb *
-drm_fb_get_from_bo(struct gbm_bo *bo,
-		   struct drm_backend *backend, uint32_t format)
+drm_fb_get_from_bo(struct gbm_bo *bo, struct drm_backend *backend,
+		   uint32_t format, enum drm_fb_type type)
 {
 	struct drm_fb *fb = gbm_bo_get_user_data(bo);
 	uint32_t handles[4] = { 0 }, pitches[4] = { 0 }, offsets[4] = { 0 };
 	int ret;
 
-	if (fb)
+	if (fb) {
+		assert(fb->type == type);
 		return fb;
+	}
 
 	fb = zalloc(sizeof *fb);
 	if (fb == NULL)
 		return NULL;
 
+	fb->type = type;
 	fb->bo = bo;
 
 	fb->width = gbm_bo_get_width(bo);
@@ -469,9 +483,7 @@ static void
 drm_fb_set_buffer(struct drm_fb *fb, struct weston_buffer *buffer)
 {
 	assert(fb->buffer_ref.buffer == NULL);
-
-	fb->is_client_buffer = 1;
-
+	assert(fb->type == BUFFER_CLIENT);
 	weston_buffer_reference(&fb->buffer_ref, buffer);
 }
 
@@ -481,15 +493,19 @@ drm_output_release_fb(struct drm_output *output, struct drm_fb *fb)
 	if (!fb)
 		return;
 
-	if (fb->map &&
-            (fb != output->dumb[0] && fb != output->dumb[1])) {
-		drm_fb_destroy_dumb(fb);
-	} else if (fb->bo) {
-		if (fb->is_client_buffer)
-			gbm_bo_destroy(fb->bo);
-		else
-			gbm_surface_release_buffer(output->gbm_surface,
-						   fb->bo);
+	switch (fb->type) {
+	case BUFFER_PIXMAN_DUMB:
+		/* nothing: pixman buffers are destroyed manually */
+		break;
+	case BUFFER_CLIENT:
+		gbm_bo_destroy(fb->bo);
+		break;
+	case BUFFER_GBM_SURFACE:
+		gbm_surface_release_buffer(output->gbm_surface, fb->bo);
+		break;
+	default:
+		assert(NULL);
+		break;
 	}
 }
 
@@ -568,7 +584,7 @@ drm_output_prepare_scanout_view(struct drm_output *output,
 		return NULL;
 	}
 
-	output->next = drm_fb_get_from_bo(bo, b, format);
+	output->next = drm_fb_get_from_bo(bo, b, format, BUFFER_CLIENT);
 	if (!output->next) {
 		gbm_bo_destroy(bo);
 		return NULL;
@@ -594,7 +610,8 @@ drm_output_render_gl(struct drm_output *output, pixman_region32_t *damage)
 		return;
 	}
 
-	output->next = drm_fb_get_from_bo(bo, b, output->gbm_format);
+	output->next = drm_fb_get_from_bo(bo, b, output->gbm_format,
+					  BUFFER_GBM_SURFACE);
 	if (!output->next) {
 		weston_log("failed to get drm_fb for bo\n");
 		gbm_surface_release_buffer(output->gbm_surface, bo);
@@ -1079,7 +1096,7 @@ drm_output_prepare_overlay_view(struct drm_output *output,
 		return NULL;
 	}
 
-	s->next = drm_fb_get_from_bo(bo, b, format);
+	s->next = drm_fb_get_from_bo(bo, b, format, BUFFER_CLIENT);
 	if (!s->next) {
 		gbm_bo_destroy(bo);
 		return NULL;
-- 
1.9.1

