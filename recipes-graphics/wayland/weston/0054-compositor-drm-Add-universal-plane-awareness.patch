From 1c10f03677146eede5a239533d4268a7ed3b2850 Mon Sep 17 00:00:00 2001
From: Pekka Paalanen <pekka.paalanen@collabora.co.uk>
Date: Wed, 20 May 2015 23:01:44 +0100
Subject: [PATCH 54/94] compositor-drm: Add universal plane awareness
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Add awareness of, rather than support for, universal planes. Activate
the client cap when we start if possible, and if this is activated,
studiously ignore non-overlay planes. For now.

Differential Revision: https://phabricator.freedesktop.org/D1495

Signed-off-by: Daniel Stone <daniels@collabora.com>
Co-authored-with: Pekka Paalanen <pekka.paalanen@collabora.co.uk>
Co-authored-with: Louis-Francis Ratt√©-Boulianne <louis-francis.ratte-boulianne@collabora.co.uk>
---
 src/compositor-drm.c | 88 ++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 88 insertions(+)

diff --git a/src/compositor-drm.c b/src/compositor-drm.c
index fc4baf1..492574d 100644
--- a/src/compositor-drm.c
+++ b/src/compositor-drm.c
@@ -61,10 +61,21 @@
 #include "linux-dmabuf.h"
 #include "linux-dmabuf-unstable-v1-server-protocol.h"
 
+#ifndef static_assert
+#define static_assert(cond) \
+   do { \
+      (void) sizeof(char [1 - 2*!(COND)]); \
+   } while (0)
+#endif
+
 #ifndef DRM_CAP_TIMESTAMP_MONOTONIC
 #define DRM_CAP_TIMESTAMP_MONOTONIC 0x6
 #endif
 
+#ifndef DRM_CLIENT_CAP_UNIVERSAL_PLANES
+#define DRM_CLIENT_CAP_UNIVERSAL_PLANES 2
+#endif
+
 #ifndef DRM_CAP_CURSOR_WIDTH
 #define DRM_CAP_CURSOR_WIDTH 0x8
 #endif
@@ -78,6 +89,24 @@
 #endif
 
 /**
+ * List of properties attached to DRM planes
+ */
+enum wdrm_plane_property {
+	WDRM_PLANE_TYPE = 0,
+	WDRM_PLANE__COUNT
+};
+
+/**
+ * Possible values for the WDRM_PLANE_TYPE property.
+ */
+enum wdrm_plane_type {
+	WDRM_PLANE_TYPE_PRIMARY = 0,
+	WDRM_PLANE_TYPE_CURSOR,
+	WDRM_PLANE_TYPE_OVERLAY,
+	WDRM_PLANE_TYPE__COUNT
+};
+
+/**
  * List of properties attached to a DRM connector
  */
 enum wdrm_connector_property {
@@ -148,10 +177,14 @@ struct drm_backend {
 
 	int cursors_are_broken;
 
+	bool universal_planes;
+
 	int use_pixman;
 
 	struct udev_input input;
 
+	struct drm_property_info props_plane[WDRM_PLANE__COUNT];
+
 	/* Holds the properties for connectors */
 	struct drm_property_info props_conn[WDRM_CONNECTOR__COUNT];
 
@@ -234,6 +267,8 @@ struct drm_plane {
 	struct drm_output *output;
 	struct drm_backend *backend;
 
+	enum wdrm_plane_type type;
+
 	uint32_t possible_crtcs;
 	uint32_t plane_id;
 	uint32_t count_formats;
@@ -1970,6 +2005,11 @@ init_drm(struct drm_backend *b, struct udev_device *device)
 	else
 		b->cursor_height = 64;
 
+	ret = drmSetClientCap(b->drm.fd, DRM_CLIENT_CAP_UNIVERSAL_PLANES, 1);
+	b->universal_planes = (ret == 0);
+	weston_log("DRM: %s universal planes\n",
+		   b->universal_planes ? "supports" : "does not support");
+
 	return 0;
 }
 
@@ -2082,6 +2122,7 @@ static struct drm_plane *
 drm_plane_create(struct drm_backend *b, const drmModePlane *kplane)
 {
 	struct drm_plane *plane;
+	drmModeObjectProperties *props;
 
 	plane = zalloc(sizeof(*plane) + ((sizeof(uint32_t)) *
 					  kplane->count_formats));
@@ -2097,6 +2138,20 @@ drm_plane_create(struct drm_backend *b, const drmModePlane *kplane)
 	memcpy(plane->formats, kplane->formats,
 	       kplane->count_formats * sizeof(kplane->formats[0]));
 
+	props = drmModeObjectGetProperties(b->drm.fd, kplane->plane_id,
+					   DRM_MODE_OBJECT_PLANE);
+	if (!props) {
+		weston_log("couldn't get plane properties\n");
+		free(plane);
+		return NULL;
+	}
+	drm_property_info_update(b, b->props_plane, WDRM_PLANE__COUNT, props);
+	plane->type =
+		drm_property_get_value(&b->props_plane[WDRM_PLANE_TYPE],
+				       props,
+				       WDRM_PLANE_TYPE_OVERLAY);
+	drmModeFreeObjectProperties(props);
+
 	weston_plane_init(&plane->base, b->compositor, 0, 0);
 	wl_list_insert(&b->sprite_list, &plane->link);
 
@@ -2141,6 +2196,31 @@ create_sprites(struct drm_backend *b)
 	struct drm_plane *drm_plane;
 	uint32_t i;
 
+	static struct drm_property_enum_info plane_type_enums[] = {
+		[WDRM_PLANE_TYPE_PRIMARY] = {
+			.name = "Primary",
+		},
+		[WDRM_PLANE_TYPE_OVERLAY] = {
+			.name = "Overlay",
+		},
+		[WDRM_PLANE_TYPE_CURSOR] = {
+			.name = "Cursor",
+		},
+	};
+	static const struct drm_property_info plane_props[] = {
+		[WDRM_PLANE_TYPE] = {
+			.name = "type",
+			.enum_values = plane_type_enums,
+			.num_enum_values = WDRM_PLANE_TYPE__COUNT,
+		},
+	};
+
+	if (!drm_property_info_copy(b->props_plane, plane_props,
+				    WDRM_PLANE__COUNT)) {
+		weston_log("failed to copy plane property info\n");
+		return;
+	}
+
 	kplane_res = drmModeGetPlaneResources(b->drm.fd);
 	if (!kplane_res) {
 		weston_log("failed to get plane resources: %s\n",
@@ -2158,6 +2238,12 @@ create_sprites(struct drm_backend *b)
 		if (!drm_plane)
 			continue;
 
+		/* Ignore non-overlay planes for now. */
+		if (drm_plane->type != WDRM_PLANE_TYPE_OVERLAY) {
+			drm_plane_destroy(drm_plane);
+			continue;
+		}
+
 		weston_compositor_stack_plane(b->compositor, &drm_plane->base,
 					      &b->compositor->primary_plane);
 	}
@@ -2179,6 +2265,8 @@ destroy_sprites(struct drm_backend *backend)
 
 	wl_list_for_each_safe(plane, next, &backend->sprite_list, link)
 		drm_plane_destroy(plane);
+
+	drm_property_info_free(backend->props_plane, WDRM_PLANE__COUNT);
 }
 
 /**
-- 
1.9.1

