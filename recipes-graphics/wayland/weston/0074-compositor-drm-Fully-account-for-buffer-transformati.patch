From ac74062c5b3ee124e02b2cc284f67db2ce2afc0f Mon Sep 17 00:00:00 2001
From: Daniel Stone <daniels@collabora.com>
Date: Tue, 7 Feb 2017 18:48:19 +0000
Subject: [PATCH 74/94] compositor-drm: Fully account for buffer transformation

In our new and improved helper to determine the src/dest values for a
buffer on a given plane, make sure we account for all buffer
transformations, including viewport clipping.

Rather than badly open-coding it ourselves, just use the helper which
does exactly this.

Signed-off-by: Daniel Stone <daniels@collabora.com>
Reported-by: Tiago Gomes <tiago.gomes@codethink.co.uk>
---
 src/compositor-drm.c | 50 +++++++++++++++++---------------------------------
 1 file changed, 17 insertions(+), 33 deletions(-)

diff --git a/src/compositor-drm.c b/src/compositor-drm.c
index 5746819..25ab20c 100644
--- a/src/compositor-drm.c
+++ b/src/compositor-drm.c
@@ -1131,9 +1131,9 @@ drm_plane_state_coords_for_view(struct drm_plane_state *state,
 				struct weston_view *ev)
 {
 	struct drm_output *output = state->output;
-	struct weston_buffer_viewport *viewport = &ev->surface->buffer_viewport;
 	pixman_region32_t dest_rect, src_rect;
 	pixman_box32_t *box, tbox;
+	float sxf1, syf1, sxf2, syf2;
 	wl_fixed_t sx1, sy1, sx2, sy2;
 
 	/* Update the base weston_plane co-ordinates. */
@@ -1160,52 +1160,36 @@ drm_plane_state_coords_for_view(struct drm_plane_state *state,
 	state->dest_h = tbox.y2 - tbox.y1;
 	pixman_region32_fini(&dest_rect);
 
-	/* Now calculate the source rectangle, by finding the points in the
-	 * view and working backwards to source co-ordinates. */
+	/* Now calculate the source rectangle, by finding the extents of the
+	 * view, and working backwards to source co-ordinates. */
 	pixman_region32_init(&src_rect);
 	pixman_region32_intersect(&src_rect, &ev->transform.boundingbox,
 				  &output->base.region);
 	box = pixman_region32_extents(&src_rect);
+	weston_view_from_global_float(ev, box->x1, box->y1, &sxf1, &syf1);
+	weston_surface_to_buffer_float(ev->surface, sxf1, syf1, &sxf1, &syf1);
+	weston_view_from_global_float(ev, box->x2, box->y2, &sxf2, &syf2);
+	weston_surface_to_buffer_float(ev->surface, sxf2, syf2, &sxf2, &syf2);
+	pixman_region32_fini(&src_rect);
 
-	/* Accounting for any transformations made to this particular surface
-	 * view, find the source rectangle to use. */
-	weston_view_from_global_fixed(ev,
-				      wl_fixed_from_int(box->x1),
-				      wl_fixed_from_int(box->y1),
-				      &sx1, &sy1);
-	weston_view_from_global_fixed(ev,
-				      wl_fixed_from_int(box->x2),
-				      wl_fixed_from_int(box->y2),
-				      &sx2, &sy2);
-
-	/* XXX: How is this possible ... ? */
+	/* Transforms might give us slightly out-of-bounds co-ordinates. */
+	sx1 = wl_fixed_from_double(sxf1);
 	if (sx1 < 0)
 		sx1 = 0;
+	sy1 = wl_fixed_from_double(syf1);
 	if (sy1 < 0)
 		sy1 = 0;
+	sx2 = wl_fixed_from_double(sxf2);
 	if (sx2 > wl_fixed_from_int(ev->surface->width))
 		sx2 = wl_fixed_from_int(ev->surface->width);
+	sy2 = wl_fixed_from_double(syf2);
 	if (sy2 > wl_fixed_from_int(ev->surface->height))
 		sy2 = wl_fixed_from_int(ev->surface->height);
 
-	tbox.x1 = sx1;
-	tbox.y1 = sy1;
-	tbox.x2 = sx2;
-	tbox.y2 = sy2;
-
-	/* Apply viewport transforms in reverse, to get the source co-ordinates
-	 * in buffer space. */
-	tbox = weston_transformed_rect(wl_fixed_from_int(ev->surface->width),
-				       wl_fixed_from_int(ev->surface->height),
-				       viewport->buffer.transform,
-				       viewport->buffer.scale,
-				       tbox);
-
-	state->src_x = tbox.x1 << 8;
-	state->src_y = tbox.y1 << 8;
-	state->src_w = (tbox.x2 - tbox.x1) << 8;
-	state->src_h = (tbox.y2 - tbox.y1) << 8;
-	pixman_region32_fini(&src_rect);
+	state->src_x = sx1 << 8;
+	state->src_y = sy1 << 8;
+	state->src_w = (sx2 - sx1) << 8;
+	state->src_h = (sy2 - sy1) << 8;
 }
 
 /**
-- 
1.9.1

