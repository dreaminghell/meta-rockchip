From 7dd44e274de5463ebb3e1722acc7fad6ca146bea Mon Sep 17 00:00:00 2001
From: Daniel Stone <daniels@collabora.com>
Date: Mon, 24 Oct 2016 14:54:53 +0100
Subject: [PATCH 46/94] compositor-drm: Return FB directly from render

Instead of setting state members directly in the drm_output_render
functions (to paint using Pixman or GL), just return a drm_fb, and let
the core function place it in state.

Signed-off-by: Daniel Stone <daniels@collabora.com>

Differential Revision: https://phabricator.freedesktop.org/D1419
---
 src/compositor-drm.c | 30 +++++++++++++++++++-----------
 1 file changed, 19 insertions(+), 11 deletions(-)

diff --git a/src/compositor-drm.c b/src/compositor-drm.c
index a3051de..9ef84be 100644
--- a/src/compositor-drm.c
+++ b/src/compositor-drm.c
@@ -627,11 +627,12 @@ drm_output_prepare_scanout_view(struct drm_output *output,
 	return &output->fb_plane;
 }
 
-static void
+static struct drm_fb *
 drm_output_render_gl(struct drm_output *output, pixman_region32_t *damage)
 {
 	struct drm_backend *b = to_drm_backend(output->base.compositor);
 	struct gbm_bo *bo;
+	struct drm_fb *ret;
 
 	output->base.compositor->renderer->repaint_output(&output->base,
 							  damage);
@@ -639,20 +640,21 @@ drm_output_render_gl(struct drm_output *output, pixman_region32_t *damage)
 	bo = gbm_surface_lock_front_buffer(output->gbm_surface);
 	if (!bo) {
 		weston_log("failed to lock front buffer: %m\n");
-		return;
+		return NULL;
 	}
 
-	output->fb_pending = drm_fb_get_from_bo(bo, b, output->gbm_format,
-						BUFFER_GBM_SURFACE);
-	if (!output->fb_pending) {
+	ret = drm_fb_get_from_bo(bo, b, output->gbm_format, BUFFER_GBM_SURFACE);
+	if (!ret) {
 		weston_log("failed to get drm_fb for bo\n");
 		gbm_surface_release_buffer(output->gbm_surface, bo);
-		return;
+		return NULL;
 	}
-	output->fb_pending->gbm_surface = output->gbm_surface;
+	ret->gbm_surface = output->gbm_surface;
+
+	return ret;
 }
 
-static void
+static struct drm_fb *
 drm_output_render_pixman(struct drm_output *output, pixman_region32_t *damage)
 {
 	struct weston_compositor *ec = output->base.compositor;
@@ -668,7 +670,6 @@ drm_output_render_pixman(struct drm_output *output, pixman_region32_t *damage)
 
 	output->current_image ^= 1;
 
-	output->fb_pending = drm_fb_ref(output->dumb[output->current_image]);
 	pixman_renderer_output_set_buffer(&output->base,
 					  output->image[output->current_image]);
 
@@ -676,6 +677,8 @@ drm_output_render_pixman(struct drm_output *output, pixman_region32_t *damage)
 
 	pixman_region32_fini(&total_damage);
 	pixman_region32_fini(&previous_damage);
+
+	return drm_fb_ref(output->dumb[output->current_image]);
 }
 
 static void
@@ -683,6 +686,7 @@ drm_output_render(struct drm_output *output, pixman_region32_t *damage)
 {
 	struct weston_compositor *c = output->base.compositor;
 	struct drm_backend *b = to_drm_backend(c);
+	struct drm_fb *fb;
 
 	/* If we already have a client buffer promoted to scanout, then we don't
 	 * want to render. */
@@ -690,9 +694,13 @@ drm_output_render(struct drm_output *output, pixman_region32_t *damage)
 		return;
 
 	if (b->use_pixman)
-		drm_output_render_pixman(output, damage);
+		fb = drm_output_render_pixman(output, damage);
 	else
-		drm_output_render_gl(output, damage);
+		fb = drm_output_render_gl(output, damage);
+
+	if (!fb)
+		return;
+	output->fb_pending = fb;
 
 	pixman_region32_subtract(&c->primary_plane.damage,
 				 &c->primary_plane.damage, damage);
-- 
1.9.1

