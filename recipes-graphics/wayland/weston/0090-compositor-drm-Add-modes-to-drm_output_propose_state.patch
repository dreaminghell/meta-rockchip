From 8ced2babb992c2d54f15de6092226243349637f5 Mon Sep 17 00:00:00 2001
From: Daniel Stone <daniels@collabora.com>
Date: Thu, 8 Dec 2016 17:19:09 +0000
Subject: [PATCH 90/94] compositor-drm: Add modes to drm_output_propose_state

Add support for multiple modes: toggling whether or not the renderer
and/or planes are acceptable. This will be used to implement a smarter
plane-placement heuristic when we have support for testing output
states.

Signed-off-by: Daniel Stone <daniels@collabora.com>

Differential Revision: https://phabricator.freedesktop.org/D1532
---
 src/compositor-drm.c | 37 +++++++++++++++++++++++++++++++------
 1 file changed, 31 insertions(+), 6 deletions(-)

diff --git a/src/compositor-drm.c b/src/compositor-drm.c
index 834c37b..690e94d 100644
--- a/src/compositor-drm.c
+++ b/src/compositor-drm.c
@@ -1653,6 +1653,11 @@ drm_output_assign_state(struct drm_output_state *state,
 	}
 }
 
+enum drm_output_propose_state_mode {
+	DRM_OUTPUT_PROPOSE_STATE_MIXED, /**< mix renderer & planes */
+	DRM_OUTPUT_PROPOSE_STATE_PLANES_ONLY, /**< only assign to planes */
+};
+
 static struct weston_plane *
 drm_output_prepare_scanout_view(struct drm_output_state *output_state,
 				struct weston_view *ev)
@@ -2810,13 +2815,17 @@ err:
 
 static struct drm_output_state *
 drm_output_propose_state(struct weston_output *output_base,
-			 struct drm_pending_state *pending_state)
+			 struct drm_pending_state *pending_state,
+			 enum drm_output_propose_state_mode mode)
 {
 	struct drm_output *output = to_drm_output(output_base);
+	struct drm_backend *b = to_drm_backend(output_base->compositor);
 	struct drm_output_state *state;
 	struct weston_view *ev;
 	pixman_region32_t surface_overlap, renderer_region, occluded_region;
 	struct weston_plane *primary = &output_base->compositor->primary_plane;
+	bool renderer_ok = (mode != DRM_OUTPUT_PROPOSE_STATE_PLANES_ONLY);
+	bool planes_ok = !b->sprites_are_broken;
 
 	assert(!output->state_last);
 	state = drm_output_state_duplicate(output->state_cur,
@@ -2826,6 +2835,7 @@ drm_output_propose_state(struct weston_output *output_base,
 	/*
 	 * Find a surface for each sprite in the output using some heuristics:
 	 * 1) size
+
 	 * 2) frequency of update
 	 * 3) opacity (though some hw might support alpha blending)
 	 * 4) clipping (this can be fixed with color keys)
@@ -2878,24 +2888,38 @@ drm_output_propose_state(struct weston_output *output_base,
 					      &occluded_region,
 					      &ev->transform.boundingbox);
 
-		if (next_plane == NULL)
+		/* The cursor plane is 'special' in the sense that we can still
+		 * place it in the legacy API, and we gate that with a separate
+		 * cursors_are_broken flag. */
+		if (next_plane == NULL && !b->cursors_are_broken)
 			next_plane = drm_output_prepare_cursor_view(state, ev);
+		if (!planes_ok)
+			next_plane = primary;
+
 		if (next_plane == NULL)
 			next_plane = drm_output_prepare_scanout_view(state, ev);
 		if (next_plane == NULL)
 			next_plane = drm_output_prepare_overlay_view(state, ev);
-		if (next_plane == NULL)
-			next_plane = primary;
 
-		if (next_plane == primary)
+		if (!next_plane || next_plane == primary) {
+			if (!renderer_ok)
+				goto err;
+
 			pixman_region32_union(&renderer_region,
 					      &renderer_region,
 					      &ev->transform.boundingbox);
+		}
 	}
 	pixman_region32_fini(&renderer_region);
 	pixman_region32_fini(&occluded_region);
 
 	return state;
+
+err:
+	pixman_region32_fini(&renderer_region);
+	pixman_region32_fini(&occluded_region);
+	drm_output_state_free(state);
+	return NULL;
 }
 
 static void
@@ -2909,7 +2933,8 @@ drm_assign_planes(struct weston_output *output_base, void *repaint_data)
 	struct weston_view *ev;
 	struct weston_plane *primary = &output_base->compositor->primary_plane;
 
-	state = drm_output_propose_state(output_base, pending_state);
+	state = drm_output_propose_state(output_base, pending_state,
+					 DRM_OUTPUT_PROPOSE_STATE_MIXED);
 
 	wl_list_for_each(ev, &output_base->compositor->view_list, link) {
 		struct drm_plane *target_plane = NULL;
-- 
1.9.1

