From a67b8040c1ae76a93842de7b6fc8d5e29c4f558f Mon Sep 17 00:00:00 2001
From: Daniel Stone <daniels@collabora.com>
Date: Tue, 14 Feb 2017 17:51:30 +0000
Subject: [PATCH 63/94] compositor-drm: Track unused connectors and CRTCs

Rather than a more piecemeal approach at backend creation, explicitly
track connectors and CRTCs we do not intend to use, so we can ensure
they are disabled where appropriate.

Signed-off-by: Daniel Stone <daniels@collabora.com>
---
 src/compositor-drm.c | 54 ++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 54 insertions(+)

diff --git a/src/compositor-drm.c b/src/compositor-drm.c
index 46f56f0..11623de 100644
--- a/src/compositor-drm.c
+++ b/src/compositor-drm.c
@@ -190,6 +190,9 @@ struct drm_backend {
 
 	void *repaint_data;
 
+	struct wl_array unused_connectors;
+	struct wl_array unused_crtcs;
+
 	int cursors_are_broken;
 
 	bool universal_planes;
@@ -3917,6 +3920,47 @@ err_free:
 	return -1;
 }
 
+/**
+ * Update the list of unused connectors and CRTCs
+ *
+ * This keeps the unused_connectors and unused_crtcs arrays up to date.
+ *
+ * @param b Weston backend structure
+ * @param resources DRM resources for this device
+ */
+static void
+drm_backend_update_unused_outputs(struct drm_backend *b, drmModeRes *resources)
+{
+	int i;
+
+	wl_array_release(&b->unused_connectors);
+	wl_array_init(&b->unused_connectors);
+
+	for (i = 0; i < resources->count_connectors; i++) {
+		uint32_t *connector_id;
+
+		if (drm_output_find_by_connector(b, resources->connectors[i]))
+			continue;
+
+		connector_id = wl_array_add(&b->unused_connectors,
+					    sizeof(*connector_id));
+		*connector_id = resources->connectors[i];
+	}
+
+	wl_array_release(&b->unused_crtcs);
+	wl_array_init(&b->unused_crtcs);
+
+	for (i = 0; i < resources->count_crtcs; i++) {
+		uint32_t *crtc_id;
+
+		if (drm_output_find_by_crtc(b, resources->crtcs[i]))
+			continue;
+
+		crtc_id = wl_array_add(&b->unused_crtcs, sizeof(*crtc_id));
+		*crtc_id = resources->crtcs[i];
+	}
+}
+
 static int
 create_outputs(struct drm_backend *b, uint32_t option_connector,
 	       struct udev_device *drm_device)
@@ -3986,6 +4030,8 @@ create_outputs(struct drm_backend *b, uint32_t option_connector,
 	if (wl_list_empty(&b->compositor->output_list))
 		weston_log("No currently active connector found.\n");
 
+	drm_backend_update_unused_outputs(b, resources);
+
 	drmModeFreeResources(resources);
 
 	return 0;
@@ -4078,6 +4124,8 @@ update_outputs(struct drm_backend *b, struct udev_device *drm_device)
 		drm_output_destroy(&output->base);
 	}
 
+	drm_backend_update_unused_outputs(b, resources);
+
 	free(connected);
 	drmModeFreeResources(resources);
 }
@@ -4142,6 +4190,9 @@ drm_destroy(struct weston_compositor *ec)
 
 	weston_launcher_destroy(ec->launcher);
 
+	wl_array_release(&b->unused_crtcs);
+	wl_array_release(&b->unused_connectors);
+
 	close(b->drm.fd);
 	free(b);
 }
@@ -4453,6 +4504,9 @@ drm_backend_create(struct weston_compositor *compositor,
 	if (b == NULL)
 		return NULL;
 
+	wl_array_init(&b->unused_crtcs);
+	wl_array_init(&b->unused_connectors);
+
 	/*
 	 * KMS support for hardware planes cannot properly synchronize
 	 * without nuclear page flip. Without nuclear/atomic, hw plane
-- 
1.9.1

