From cf25ef6631cffc828bbb4b8f9ee9541277ca819e Mon Sep 17 00:00:00 2001
From: Daniel Stone <daniels@collabora.com>
Date: Fri, 9 Dec 2016 17:32:10 +0000
Subject: [PATCH 91/94] compositor-drm: Return plane state from plane
 preparation

Return a pointer to the plane state, rather than indirecting via a
weston_plane.

Signed-off-by: Daniel Stone <daniels@collabora.com>

Differential Revision: https://phabricator.freedesktop.org/D1534
---
 src/compositor-drm.c | 54 +++++++++++++++++++++++++++-------------------------
 1 file changed, 28 insertions(+), 26 deletions(-)

diff --git a/src/compositor-drm.c b/src/compositor-drm.c
index 690e94d..ffe272c 100644
--- a/src/compositor-drm.c
+++ b/src/compositor-drm.c
@@ -1658,7 +1658,7 @@ enum drm_output_propose_state_mode {
 	DRM_OUTPUT_PROPOSE_STATE_PLANES_ONLY, /**< only assign to planes */
 };
 
-static struct weston_plane *
+static struct drm_plane_state *
 drm_output_prepare_scanout_view(struct drm_output_state *output_state,
 				struct weston_view *ev)
 {
@@ -1697,7 +1697,7 @@ drm_output_prepare_scanout_view(struct drm_output_state *output_state,
 	    state->dest_h != (unsigned) output->base.current_mode->height)
 		goto err;
 
-	return &scanout_plane->base;
+	return state;
 
 err:
 	drm_plane_state_put_back(state);
@@ -1871,8 +1871,8 @@ drm_output_apply_state_legacy(struct drm_output_state *state)
 		&backend->props_conn[WDRM_CONNECTOR_DPMS];
 	struct drm_plane_state *scanout_state;
 	struct drm_plane_state *ps;
-	struct drm_plane *p;
 	struct drm_mode *mode;
+	struct drm_plane *p;
 	struct timespec now;
 	int ret = 0;
 
@@ -2557,7 +2557,7 @@ atomic_flip_handler(int fd, unsigned int crtc_id, unsigned int frame,
 	drm_output_update_complete(output, flags, sec, usec);
 }
 
-static struct weston_plane *
+static struct drm_plane_state *
 drm_output_prepare_overlay_view(struct drm_output_state *output_state,
 				struct weston_view *ev)
 {
@@ -2620,7 +2620,7 @@ drm_output_prepare_overlay_view(struct drm_output_state *output_state,
 	    state->src_h != state->dest_h << 16)
 		goto err;
 
-	return &p->base;
+	return state;
 
 err:
 	drm_plane_state_put_back(state);
@@ -2664,7 +2664,7 @@ cursor_bo_update(struct drm_backend *b, struct gbm_bo *bo,
 		weston_log("failed update cursor: %m\n");
 }
 
-static struct weston_plane *
+static struct drm_plane_state *
 drm_output_prepare_cursor_view(struct drm_output_state *output_state,
 			       struct weston_view *ev)
 {
@@ -2753,7 +2753,7 @@ drm_output_prepare_cursor_view(struct drm_output_state *output_state,
 	if (needs_update)
 		cursor_bo_update(b, plane_state->fb->bo, ev);
 
-	return &plane->base;
+	return plane_state;
 
 err:
 	drm_plane_state_put_back(plane_state);
@@ -2823,7 +2823,6 @@ drm_output_propose_state(struct weston_output *output_base,
 	struct drm_output_state *state;
 	struct weston_view *ev;
 	pixman_region32_t surface_overlap, renderer_region, occluded_region;
-	struct weston_plane *primary = &output_base->compositor->primary_plane;
 	bool renderer_ok = (mode != DRM_OUTPUT_PROPOSE_STATE_PLANES_ONLY);
 	bool planes_ok = !b->sprites_are_broken;
 
@@ -2850,7 +2849,8 @@ drm_output_propose_state(struct weston_output *output_base,
 	pixman_region32_init(&occluded_region);
 
 	wl_list_for_each(ev, &output_base->compositor->view_list, link) {
-		struct weston_plane *next_plane = NULL;
+		struct drm_plane_state *ps = NULL;
+		bool force_renderer = false;
 		bool occluded = false;
 
 		/* If this view doesn't touch our output at all, there's no
@@ -2861,7 +2861,7 @@ drm_output_propose_state(struct weston_output *output_base,
 		/* We only assign planes to views which are exclusively present
 		 * on our output. */
 		if (ev->output_mask != (1u << output->base.id))
-			next_plane = primary;
+			force_renderer = true;
 
 		/* Ignore views we know to be totally occluded. */
 		pixman_region32_init(&surface_overlap);
@@ -2880,9 +2880,12 @@ drm_output_propose_state(struct weston_output *output_base,
 		pixman_region32_intersect(&surface_overlap, &renderer_region,
 					  &ev->transform.boundingbox);
 		if (pixman_region32_not_empty(&surface_overlap))
-			next_plane = primary;
+			force_renderer = true;
 		pixman_region32_fini(&surface_overlap);
 
+		if (force_renderer && !renderer_ok)
+			goto err;
+
 		if (drm_view_is_opaque(ev))
 			pixman_region32_union(&occluded_region,
 					      &occluded_region,
@@ -2891,24 +2894,23 @@ drm_output_propose_state(struct weston_output *output_base,
 		/* The cursor plane is 'special' in the sense that we can still
 		 * place it in the legacy API, and we gate that with a separate
 		 * cursors_are_broken flag. */
-		if (next_plane == NULL && !b->cursors_are_broken)
-			next_plane = drm_output_prepare_cursor_view(state, ev);
+		if (!force_renderer && !b->cursors_are_broken)
+			ps = drm_output_prepare_cursor_view(state, ev);
 		if (!planes_ok)
-			next_plane = primary;
+			force_renderer = true;
+		if (!force_renderer && !ps)
+			ps = drm_output_prepare_scanout_view(state, ev);
+		if (!force_renderer && !ps)
+			ps = drm_output_prepare_overlay_view(state, ev);
 
-		if (next_plane == NULL)
-			next_plane = drm_output_prepare_scanout_view(state, ev);
-		if (next_plane == NULL)
-			next_plane = drm_output_prepare_overlay_view(state, ev);
-
-		if (!next_plane || next_plane == primary) {
-			if (!renderer_ok)
-				goto err;
+		if (ps)
+			continue;
+		if (!renderer_ok)
+			goto err;
 
-			pixman_region32_union(&renderer_region,
-					      &renderer_region,
-					      &ev->transform.boundingbox);
-		}
+		pixman_region32_union(&renderer_region,
+				      &renderer_region,
+				      &ev->transform.boundingbox);
 	}
 	pixman_region32_fini(&renderer_region);
 	pixman_region32_fini(&occluded_region);
-- 
1.9.1

