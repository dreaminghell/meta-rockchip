From 778ebb2cac0f5a76bae92d35265fc9c68f8a5fb5 Mon Sep 17 00:00:00 2001
From: Daniel Stone <daniels@collabora.com>
Date: Thu, 21 May 2015 00:00:57 +0100
Subject: [PATCH 55/94] compositor-drm: Track all plane types

Retain drm_plane tracking objects for all actual DRM planes when using
universal planes, not just overlay planes. Rename uses of 'sprite' to
'plane' to make it clear that it can now be any kind of plane, not just
an overlay/sprite.

These are currently unused.

Differential Revision: https://phabricator.freedesktop.org/D1496

Signed-off-by: Daniel Stone <daniels@collabora.com>
---
 src/compositor-drm.c | 74 +++++++++++++++++++++++++++++-----------------------
 1 file changed, 41 insertions(+), 33 deletions(-)

diff --git a/src/compositor-drm.c b/src/compositor-drm.c
index 492574d..7ad15da 100644
--- a/src/compositor-drm.c
+++ b/src/compositor-drm.c
@@ -171,7 +171,7 @@ struct drm_backend {
 	int min_height, max_height;
 	int no_addfb2;
 
-	struct wl_list sprite_list;
+	struct wl_list plane_list;
 	int sprites_are_broken;
 	int sprites_hidden;
 
@@ -1104,7 +1104,7 @@ drm_output_repaint(struct weston_output *output_base,
 	struct drm_output *output = to_drm_output(output_base);
 	struct drm_backend *backend =
 		to_drm_backend(output->base.compositor);
-	struct drm_plane *s;
+	struct drm_plane *p;
 	struct drm_mode *mode;
 	int ret = 0;
 
@@ -1150,26 +1150,31 @@ drm_output_repaint(struct weston_output *output_base,
 	/*
 	 * Now, update all the sprite surfaces
 	 */
-	wl_list_for_each(s, &backend->sprite_list, link) {
+	wl_list_for_each(p, &backend->plane_list, link) {
 		uint32_t flags = 0, fb_id = 0;
 		drmVBlank vbl = {
 			.request.type = DRM_VBLANK_RELATIVE | DRM_VBLANK_EVENT,
 			.request.sequence = 1,
 		};
 
-		if ((!s->fb_current && !s->fb_pending) ||
-		    !drm_plane_crtc_supported(output, s))
+		if (p->type != WDRM_PLANE_TYPE_OVERLAY)
+			continue;
+
+		/* XXX: Set output much earlier, so we don't attempt to place
+		 *      planes on entirely the wrong output. */
+		if ((!p->fb_current && !p->fb_pending) ||
+		    !drm_plane_crtc_supported(output, p))
 			continue;
 
-		if (s->fb_pending && !backend->sprites_hidden)
-			fb_id = s->fb_pending->fb_id;
+		if (p->fb_pending && !backend->sprites_hidden)
+			fb_id = p->fb_pending->fb_id;
 
-		ret = drmModeSetPlane(backend->drm.fd, s->plane_id,
+		ret = drmModeSetPlane(backend->drm.fd, p->plane_id,
 				      output->crtc_id, fb_id, flags,
-				      s->dest_x, s->dest_y,
-				      s->dest_w, s->dest_h,
-				      s->src_x, s->src_y,
-				      s->src_w, s->src_h);
+				      p->dest_x, p->dest_y,
+				      p->dest_w, p->dest_h,
+				      p->src_x, p->src_y,
+				      p->src_w, p->src_h);
 		if (ret)
 			weston_log("setplane failed: %d: %s\n",
 				ret, strerror(errno));
@@ -1180,17 +1185,17 @@ drm_output_repaint(struct weston_output *output_base,
 		 * Queue a vblank signal so we know when the surface
 		 * becomes active on the display or has been replaced.
 		 */
-		vbl.request.signal = (unsigned long)s;
+		vbl.request.signal = (unsigned long) p;
 		ret = drmWaitVBlank(backend->drm.fd, &vbl);
 		if (ret) {
 			weston_log("vblank event request failed: %d: %s\n",
 				ret, strerror(errno));
 		}
 
-		s->output = output;
-		s->fb_last = s->fb_current;
-		s->fb_current = s->fb_pending;
-		s->fb_pending = NULL;
+		p->output = output;
+		p->fb_last = p->fb_current;
+		p->fb_current = p->fb_pending;
+		p->fb_pending = NULL;
 		output->vblank_pending++;
 	}
 
@@ -1433,7 +1438,10 @@ drm_output_prepare_overlay_view(struct drm_output *output,
 	if (ev->alpha != 1.0f)
 		return NULL;
 
-	wl_list_for_each(p, &b->sprite_list, link) {
+	wl_list_for_each(p, &b->plane_list, link) {
+		if (p->type != WDRM_PLANE_TYPE_OVERLAY)
+			continue;
+
 		if (!drm_plane_crtc_supported(output, p))
 			continue;
 
@@ -2153,7 +2161,7 @@ drm_plane_create(struct drm_backend *b, const drmModePlane *kplane)
 	drmModeFreeObjectProperties(props);
 
 	weston_plane_init(&plane->base, b->compositor, 0, 0);
-	wl_list_insert(&b->sprite_list, &plane->link);
+	wl_list_insert(&b->plane_list, &plane->link);
 
 	return plane;
 }
@@ -2238,14 +2246,10 @@ create_sprites(struct drm_backend *b)
 		if (!drm_plane)
 			continue;
 
-		/* Ignore non-overlay planes for now. */
-		if (drm_plane->type != WDRM_PLANE_TYPE_OVERLAY) {
-			drm_plane_destroy(drm_plane);
-			continue;
-		}
-
-		weston_compositor_stack_plane(b->compositor, &drm_plane->base,
-					      &b->compositor->primary_plane);
+		if (drm_plane->type == WDRM_PLANE_TYPE_OVERLAY)
+			weston_compositor_stack_plane(b->compositor,
+						      &drm_plane->base,
+						      &b->compositor->primary_plane);
 	}
 
 	drmModeFreePlaneResources(kplane_res);
@@ -2263,7 +2267,7 @@ destroy_sprites(struct drm_backend *backend)
 {
 	struct drm_plane *plane, *next;
 
-	wl_list_for_each_safe(plane, next, &backend->sprite_list, link)
+	wl_list_for_each_safe(plane, next, &backend->plane_list, link)
 		drm_plane_destroy(plane);
 
 	drm_property_info_free(backend->props_plane, WDRM_PLANE__COUNT);
@@ -3362,7 +3366,7 @@ session_notify(struct wl_listener *listener, void *data)
 {
 	struct weston_compositor *compositor = data;
 	struct drm_backend *b = to_drm_backend(compositor);
-	struct drm_plane *sprite;
+	struct drm_plane *plane;
 	struct drm_output *output;
 
 	if (compositor->session_active) {
@@ -3392,12 +3396,16 @@ session_notify(struct wl_listener *listener, void *data)
 		output = container_of(compositor->output_list.next,
 				      struct drm_output, base.link);
 
-		wl_list_for_each(sprite, &b->sprite_list, link)
+		wl_list_for_each(plane, &b->plane_list, link) {
+			if (plane->type != WDRM_PLANE_TYPE_OVERLAY)
+				continue;
+
 			drmModeSetPlane(b->drm.fd,
-					sprite->plane_id,
+					plane->plane_id,
 					output->crtc_id, 0, 0,
 					0, 0, 0, 0, 0, 0, 0, 0);
-	};
+		}
+	}
 }
 
 /*
@@ -3726,7 +3734,7 @@ drm_backend_create(struct weston_compositor *compositor,
 
 	weston_setup_vt_switch_bindings(compositor);
 
-	wl_list_init(&b->sprite_list);
+	wl_list_init(&b->plane_list);
 	create_sprites(b);
 
 	if (udev_input_init(&b->input,
-- 
1.9.1

